(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{238:function(t,n,e){"use strict";e.r(n);var a=e(0),o=e.n(a),r=e(10),i=e.n(r),s=(e(81),e(29)),c=e(30),u=e(32),l=e(31),h=e(33),p=e(34),v=e.n(p),d=(e(83),e(73)),g=e(20),m=e(74);function f(){var t=Object(d.a)(["\n      precision highp float;\n      float PI = 3.14159265359;\n      uniform sampler2D InputTexture;\n      uniform float contrast, saturation, brightness;\n      varying vec2 uv;\n      // uniform vec3 InputRotation;\n      // A transformation matrix rotating about the x axis by th degrees.\n      mat3 Rx(float th)\n      {\n          return mat3(1, 0, 0,\n                      0, cos(th), -sin(th),\n                      0, sin(th), cos(th));\n      }\n      // A transformation matrix rotating about the y axis by th degrees.\n      mat3 Ry(float th)\n      {\n          return mat3(cos(th), 0, sin(th),\n                         0,    1,    0,\n                      -sin(th), 0, cos(th));\n      }\n      // A transformation matrix rotating about the z axis by th degrees.\n      mat3 Rz(float th)\n      {\n          return mat3(cos(th), -sin(th), 0,\n                      sin(th),  cos(th), 0,\n                        0,         0   , 1);\n      }\n\n      // Rotate a point vector by th.x then th.y then th.z, and return the rotated point.\n      vec3 rotatePoint(vec3 p, vec3 th)\n      {\n          return Rx(th.r) * Ry(th.g) * Rz(th.b) * p;\n      }\n\n      // Convert x, y pixel coordinates from an Equirectangular image into latitude/longitude coordinates.\n      vec2 uvToLatLon(vec2 uv)\n      {\n          return vec2(uv.y * PI - PI/2.0,\n                      uv.x * 2.0*PI - PI);\n      }\n\n      // Convert latitude, longitude into a 3d point on the unit-sphere.\n      vec3 latLonToPoint(vec2 latLon)\n      {\n          vec3 point;\n          point.x = cos(latLon.x) * sin(latLon.y);\n          point.y = sin(latLon.x);\n          point.z = cos(latLon.x) * cos(latLon.y);\n          return point;\n      }\n\n      // Convert a 3D point on the unit sphere into latitude and longitude.\n      vec2 pointToLatLon(vec3 point)\n      {\n          vec2 latLon;\n          latLon.x = asin(point.y);\n          latLon.y = atan(point.x, point.z);\n          return latLon;\n      }\n\n      // Convert latitude, longitude to x, y pixel coordinates on an equirectangular image.\n      vec2 latLonToUv(vec2 latLon)\n      {\n          vec2 uv;\n          uv.x = (latLon.y + PI)/(2.0*PI);\n          uv.y = (latLon.x + PI/2.0)/PI;\n          return uv;\n      }\n\n      void main()\n      {\n          vec3 InputRotation = vec3(contrast, saturation, brightness);\n          // vec2 uv = gl_TexCoord[0].xy;\n          // Latitude and Longitude of the destination pixel (uv)\n          vec2 latLon = uvToLatLon(uv);\n          // Create a point on the unit-sphere from the latitude and longitude\n              // X increases from left to right [-1 to 1]\n              // Y increases from bottom to top [-1 to 1]\n              // Z increases from back to front [-1 to 1]\n          vec3 point = latLonToPoint(latLon);\n          // Rotate the point based on the user input in radians\n          point = rotatePoint(point, InputRotation.rgb * PI);\n          // Convert back to latitude and longitude\n          latLon = pointToLatLon(point);\n          // Convert back to the normalized pixel coordinate\n          vec2 sourcePixel = latLonToUv(latLon);\n          // Set the color of the destination pixel to the color of the source pixel\n\n          gl_FragColor = texture2D(InputTexture, sourcePixel);\n      }\n\n    "]);return f=function(){return t},t}var b=g.Shaders.create({Saturate:{frag:Object(g.GLSL)(f())}}),x=function(t){function n(){return Object(s.a)(this,n),Object(u.a)(this,Object(l.a)(n).apply(this,arguments))}return Object(h.a)(n,t),Object(c.a)(n,[{key:"render",value:function(){var t=this.props,n=t.contrast,e=t.saturation,a=t.brightness;return o.a.createElement(m.Surface,{width:1200,height:600},o.a.createElement(g.Node,{shader:b.Saturate,uniforms:{contrast:n,saturation:e,brightness:a,InputTexture:"earth.jpg"}}))}}]),n}(a.Component),L=function(t){function n(){var t,e;Object(s.a)(this,n);for(var a=arguments.length,o=new Array(a),r=0;r<a;r++)o[r]=arguments[r];return(e=Object(u.a)(this,(t=Object(l.a)(n)).call.apply(t,[this].concat(o)))).state={contrast:1,saturation:1,brightness:1},e.handleContrastChange=function(t,n){e.setState({contrast:n/50})},e.handleSaturationChange=function(t,n){e.setState({saturation:n/50})},e.handleBrightnessChange=function(t,n){e.setState({brightness:n/50})},e}return Object(h.a)(n,t),Object(c.a)(n,[{key:"render",value:function(){var t=this.state,n=t.contrast,e=t.saturation,a=t.brightness;return o.a.createElement("div",{className:"App-container"},o.a.createElement("div",{className:"App-slider"},o.a.createElement("p",null,"Contrast"),o.a.createElement(v.a,{value:50*n,onChange:this.handleContrastChange}),o.a.createElement("p",null,"Saturation"),o.a.createElement(v.a,{value:50*e,onChange:this.handleSaturationChange}),o.a.createElement("p",null,"Brightness"),o.a.createElement(v.a,{value:50*a,onChange:this.handleBrightnessChange})),o.a.createElement("div",{className:"App-map"},o.a.createElement(x,{contrast:n,saturation:e,brightness:a})))}}]),n}(a.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));i.a.render(o.a.createElement(L,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(t){t.unregister()})},76:function(t,n,e){t.exports=e(238)},81:function(t,n,e){},83:function(t,n,e){}},[[76,2,1]]]);
//# sourceMappingURL=main.498fa852.chunk.js.map