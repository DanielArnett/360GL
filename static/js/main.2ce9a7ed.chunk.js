(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{113:function(n,t,e){n.exports=e(330)},118:function(n,t,e){},120:function(n,t,e){},330:function(n,t,e){"use strict";e.r(t);var o=e(0),a=e.n(o),i=e(15),r=e.n(i),l=(e(118),e(109)),c=e(40),u=e(41),s=e(43),p=e(42),h=e(44),v=e(45),P=e.n(v),d=(e(120),e(110)),f=e(31),m=e(111);function L(){var n=Object(d.a)(["\n    // TODO turn this into its own .frag file.\n      precision highp float;\n      float PI = 3.14159265359;\n      vec2 SET_TO_TRANSPARENT = vec2(-1.0, -1.0);\n      vec4 TRANSPARENT_PIXEL = vec4(0.0, 0.0, 0.0, 0.0);\n      uniform sampler2D InputTexture;\n      uniform float pitch, roll, yaw;\n      uniform int inputProjection, outputProjection;\n      varying vec2 uv;\n      bool isTransparent = false;\n      const int EQUI = 0;\n      const int FISHEYE = 1;\n      const int FLAT = 2;\n      const int SPHERE = 3;\n\n      // uniform vec3 InputRotation;\n      // A transformation matrix rotating about the x axis by th degrees.\n      mat3 Rx(float th)\n      {\n          return mat3(1, 0, 0,\n                      0, cos(th), -sin(th),\n                      0, sin(th), cos(th));\n      }\n      // A transformation matrix rotating about the y axis by th degrees.\n      mat3 Ry(float th)\n      {\n          return mat3(cos(th), 0, sin(th),\n                         0,    1,    0,\n                      -sin(th), 0, cos(th));\n      }\n      // A transformation matrix rotating about the z axis by th degrees.\n      mat3 Rz(float th)\n      {\n          return mat3(cos(th), -sin(th), 0,\n                      sin(th),  cos(th), 0,\n                        0,         0   , 1);\n      }\n\n      // Rotate a point vector by th.x then th.y then th.z, and return the rotated point.\n      vec3 rotatePoint(vec3 p, vec3 th)\n      {\n        return Rx(th.x) * Ry(th.y) * Rz(th.z) * p;\n      }\n\n      // Convert a 3D point on the unit sphere into latitude and longitude.\n      vec2 pointToLatLon(vec3 point)\n      {\n        float r = distance(vec3(0.0, 0.0, 0.0), point);\n        vec2 latLon;\n        latLon.x = asin(point.z / r);\n        latLon.y = atan(point.x, point.y);\n        return latLon;\n      }\n\n      // Convert latitude, longitude into a 3d point on the unit-sphere.\n      vec3 latLonToPoint(vec2 latLon)\n      {\n          float lat = latLon.x;\n          float lon = latLon.y;\n          vec3 point;\n          point.x = cos(lat) * sin(lon);\n          point.y = cos(lat) * cos(lon);\n          point.z = sin(lat);\n          return point;\n      }\n\n      // Convert pixel coordinates from an Equirectangular image into latitude/longitude coordinates.\n      vec2 EquiUvToLatLon(vec2 uv)\n      {\n          return vec2(uv.y * PI - PI/2.0,\n                      uv.x * 2.0*PI - PI);\n      }\n\n      // Convert  pixel coordinates from an Fisheye image into latitude/longitude coordinates.\n      vec2 FisheyeUvToLatLon(vec2 uv)\n      {\n        vec2 pos = 2.0 * uv - 1.0;\n        float r = distance(vec2(0.0, 0.0), pos);\n        // Don't bother with pixels outside of the fisheye circle\n        if (1.0 < r) {\n          isTransparent = true;\n          return SET_TO_TRANSPARENT;\n        }\n        vec2 latLon;\n        latLon.x = (1.0 - r)*(PI / 2.0);\n        // Calculate longitude\n        latLon.y = PI + atan(-pos.x, pos.y);\n          \n        if (latLon.y < 0.0) {\n          latLon.y += 2.0*PI;\n        }\n        vec3 point = latLonToPoint(latLon);\n        point = rotatePoint(point, vec3(PI/2.0, 0.0, 0.0));\n        latLon = pointToLatLon(point);\n        return latLon;\n      }\n\n      vec2 sphericalUvToLatLon(vec2 uv)\n      {\n          // Return a isTransparent pixel\n          isTransparent = true;\n          return SET_TO_TRANSPARENT;\n      }\n      \n      vec2 flatImageUvToLatLon(vec2 uv)\n      {\n        float aspectRatio = 1.0;\n        // Position of the source pixel in uv coordinates in the range [-1,1]\n        vec2 pos = 2.0 * uv - 1.0;\n        float fieldOfView = PI/2.0;\n        vec2 imagePlaneDimensions = vec2(tan(fieldOfView / 2.0) * 2.0, (tan(fieldOfView / 2.0) * 2.0) / aspectRatio);\n        \n        // Position of the source pixel on the image plane\n        pos *= imagePlaneDimensions;\n        vec3 point = vec3(pos.x, 1.0, pos.y);\n        // point = rotatePoint(point, vec3(-PI/2.0, 0.0, 0.0));\n        return pointToLatLon(point);\n      }\n\n\n      \n      // Convert latitude, longitude into a 3d point on the unit-sphere.\n      vec3 flatLatLonToPoint(vec2 latLon)\n      {\n        vec3 point = latLonToPoint(latLon);\n        // Get phi of this point, see polar coordinate system for more details.\n        float phi = atan(point.x, -point.y);\n        // With phi, calculate the point on the image plane that is also at the angle phi\n        point.x = sin(phi) * tan(PI / 2.0 - latLon.x);\n        point.y = cos(phi) * tan(PI / 2.0 - latLon.x);\n        point.z = 1.0;\n        return point;\n      }\n      // Convert latitude, longitude to x, y pixel coordinates on an equirectangular image.\n      vec2 latLonToEquiUv(vec2 latLon)\n      {\n          vec2 uv;\n          uv.x = (latLon.y + PI)/(2.0*PI);\n          uv.y = (latLon.x + PI/2.0)/PI;\n          return uv;\n      }\n      \n      // Convert latitude, longitude to x, y pixel coordinates on the source fisheye image.\n      vec2 pointToFisheyeUv(vec3 point)\n      {\t\n        point = rotatePoint(point, vec3(-PI/2.0, 0.0, 0.0));\n        vec2 latLon = pointToLatLon(point);\n        // The distance from the source pixel to the center of the image\n        float r;\n        // phi is the angle of r on the unit circle. See polar coordinates for more details\n        float phi;\n        // Get the position of the source pixel\n        vec2 sourcePixel;\n        // Get the source pixel radius from center\n        r = 1.0 - latLon.x/(PI / 2.0);\n        // Don't bother with source pixels outside of the fisheye circle\n        if (1.0 < r) {\n          // Return a isTransparent pixel\n          isTransparent = true;\n          return SET_TO_TRANSPARENT;\n        }\n        phi = atan(-point.y, point.x);\n        \n        sourcePixel.x = r * cos(phi);\n        sourcePixel.y = r * sin(phi);\n        // Normalize the output pixel to be in the range [0,1]\n        sourcePixel += 1.0;\n        sourcePixel /= 2.0;\n        return sourcePixel;\n      }\n      \n      bool outOfFlatBounds(vec2 xy, float lower, float upper)\n      {\n        vec2 lowerBound = vec2(lower, lower);\n        vec2 upperBound = vec2(upper, upper);\n        return (any(lessThan(xy, lowerBound)) || any(greaterThan(xy, upperBound)));\n      }\n      vec2 latLonToFlatUv(vec2 latLon)\n      {\n        vec3 point = rotatePoint(latLonToPoint(latLon), vec3(-PI/2.0, 0.0, 0.0));\n        latLon = pointToLatLon(point);\n\n        vec2 xyOnImagePlane;\n        vec3 p;\n        if (latLon.x < 0.0) \n        {\n          isTransparent = true;\n          return SET_TO_TRANSPARENT;\n        }\n        // Derive a 3D point on the plane which correlates with the latitude and longitude in the fisheye image.\n        p = flatLatLonToPoint(latLon);\n        // Position of the source pixel in the source image in the range [-1,1]\n        xyOnImagePlane = p.xy / 2.0 + 0.5;\n        if (outOfFlatBounds(xyOnImagePlane, 0.0, 1.0)) \n    \t\t{\n          isTransparent = true;\n          return SET_TO_TRANSPARENT;\n        }\n        return xyOnImagePlane;\n      }\n\n      void main()\n      {\n          // int inputProjection = EQUI;\n          // int outputProjection = EQUI;\n          vec3 InputRotation = vec3(pitch, roll, yaw);\n          // Given some pixel (uv), find the latitude and longitude of that pixel\n          vec2 latLon;\n          if (outputProjection == EQUI)\n            latLon = EquiUvToLatLon(uv);\n          else if(outputProjection == FISHEYE)\n            latLon = FisheyeUvToLatLon(uv);\n          else if (outputProjection == FLAT)\n            latLon = flatImageUvToLatLon(uv);\n          else if (outputProjection == SPHERE)\n            latLon = sphericalUvToLatLon(uv);\n\n          // If a pixel is out of bounds, set it to be transparent\n          if (isTransparent)\n          {\n            gl_FragColor = TRANSPARENT_PIXEL;\n            return;\n          }\n          // Create a point on the unit-sphere from the calculated latitude and longitude\n          // This sphere uses a right-handed coordinate system\n            // X increases from left to right [-1 to 1]\n            // Y increases from back to front [-1 to 1]\n            // Z increases from bottom to top [-1 to 1]\n          vec3 point = latLonToPoint(latLon);\n          // Rotate the point based on the user input in radians\n          point = rotatePoint(point, InputRotation.rgb * PI);\n          // Convert back to latitude and longitude\n          latLon = pointToLatLon(point);\n          \n          // Convert back to the normalized pixel coordinate\n          vec2 sourcePixel;\n          if (inputProjection == EQUI)\n            sourcePixel = latLonToEquiUv(latLon);\n          else if (inputProjection == FISHEYE)\n            sourcePixel = pointToFisheyeUv(point);\n          else if (inputProjection == FLAT)\n            sourcePixel = latLonToFlatUv(latLon);\n          if (isTransparent)\n          {\n            gl_FragColor = TRANSPARENT_PIXEL;\n            return;\n          }\n          // Set the color of the destination pixel to the color of the source pixel\n\n          gl_FragColor = texture2D(InputTexture, sourcePixel);\n      }\n\n    "]);return L=function(){return n},n}var g=f.Shaders.create({Saturate:{frag:Object(f.GLSL)(L())}}),T=function(n){function t(){return Object(c.a)(this,t),Object(s.a)(this,Object(p.a)(t).apply(this,arguments))}return Object(h.a)(t,n),Object(u.a)(t,[{key:"render",value:function(){var n=this.props,t=n.pitch,e=n.roll,o=n.yaw,i=n.inputProjection,r=n.outputProjection;return a.a.createElement(m.Surface,{width:1200,height:600},a.a.createElement(f.Node,{shader:g.Saturate,uniforms:{pitch:t,roll:e,yaw:o,inputProjection:i,outputProjection:r,InputTexture:"radial.jpg"}}))}}]),t}(o.Component),x=e(57),y=e.n(x),E=e(56),j=e.n(E),I=e(18),R=e.n(I),w=function(n){function t(){var n,e;Object(c.a)(this,t);for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];return(e=Object(s.a)(this,(n=Object(p.a)(t)).call.apply(n,[this].concat(a)))).state={pitch:1,roll:1,yaw:1,inputProjection:0,outputProjection:0,name:""},e.handleProjectionChange=function(n,t){e.setState({inputProjection:t})},e.handleChange=function(n){e.setState(Object(l.a)({},n.target.name,n.target.value))},e.handlePitchChange=function(n,t){e.setState({pitch:t/50})},e.handleRollChange=function(n,t){e.setState({roll:t/50})},e.handleYawChange=function(n,t){e.setState({yaw:t/50})},e}return Object(h.a)(t,n),Object(u.a)(t,[{key:"render",value:function(){var n=this.state,t=n.pitch,e=n.roll,o=n.yaw,i=n.inputProjection,r=n.outputProjection;return a.a.createElement("div",{className:"App-container"},a.a.createElement("div",{className:"App-slider"},a.a.createElement(j.a,{shrink:!0,htmlFor:"inputProjection"},"Input Projection"),a.a.createElement(y.a,{value:this.inputProjection,onChange:this.handleChange,inputProps:{name:"inputProjection",id:"inputProjection"},displayEmpty:!0},a.a.createElement(R.a,{value:0},"Equirectangular"),a.a.createElement(R.a,{value:1},"Fisheye"),a.a.createElement(R.a,{value:2},"Rectilinear")),a.a.createElement(j.a,{htmlFor:"outputProjection"},"Output Projection"),a.a.createElement(y.a,{value:this.inputProjection,onChange:this.handleChange,inputProps:{name:"outputProjection",id:"outputProjection"}},a.a.createElement(R.a,{value:0},"Equirectangular"),a.a.createElement(R.a,{value:1},"Fisheye"),a.a.createElement(R.a,{value:2},"Rectilinear"),a.a.createElement(R.a,{value:3},"Sphere")),a.a.createElement("p",null,"Pitch"),a.a.createElement(P.a,{value:50*t,onChange:this.handlePitchChange}),a.a.createElement("p",null,"Roll"),a.a.createElement(P.a,{value:50*e,onChange:this.handleRollChange}),a.a.createElement("p",null,"Yaw"),a.a.createElement(P.a,{value:50*o,onChange:this.handleYawChange})),a.a.createElement("div",{className:"App-Projection"},a.a.createElement(T,{pitch:t,roll:e,yaw:o,inputProjection:i,outputProjection:r})))}}]),t}(o.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));r.a.render(a.a.createElement(w,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(n){n.unregister()})}},[[113,2,1]]]);
//# sourceMappingURL=main.2ce9a7ed.chunk.js.map